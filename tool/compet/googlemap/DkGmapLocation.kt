/*
 * Copyright (c) 2017-2021 DarkCompet. All rights reserved.
 */
package tool.compet.googlemap

import android.location.Location
import com.google.android.gms.maps.model.CameraPosition
import com.google.android.gms.maps.model.LatLng

/**
 * Gmap location model which wraps [com.google.android.gms.maps.model.LatLng] and other info.
 */
class DkGmapLocation {
	// Must set this
	var latLng: LatLng // latitude + longitude
	private var hasSetLatLng = false // primitive

	/**
	 * Altitude in meters above the WGS 84 reference ellipsoid.
	 */
	var alt = 0.0 // height (in meters) in relation to sea-level.

	/**
	 * Bearing is the horizontal direction of travel of this device,
	 * and is not related to the device orientation. It is guaranteed to
	 * be in the range (0.0, 360.0] if the device has a bearing.
	 *
	 * If this location does not have a bearing then 0.0 is returned.
	 */
	var bearing = 0f // in degrees

	/**
	 * Speed in meters/second over ground.
	 */
	protected var speed = 0f // in meters/second

	/**
	 * The estimated horizontal accuracy of this location, radial, in meters.
	 *
	 * We define horizontal accuracy as the radius of 68% confidence. In other
	 * words, if you draw a circle centered at this location's
	 * latitude and longitude, and with a radius equal to the accuracy,
	 * then there is a 68% probability that the true location is inside
	 * the circle.
	 *
	 * This accuracy estimation is only concerned with horizontal
	 * accuracy, and does not indicate the accuracy of bearing,
	 * velocity or altitude if those are included in this Location.
	 *
	 * If this location does not have a horizontal accuracy, then 0.0 is returned.
	 * All locations generated by the [LocationManager] include horizontal accuracy.
	 */
	protected var accuracy = 0f
	var tilt = 0f // tilt
	var zoom = 0f // zoom level
	var resolution = 0.0 // resolution

	/**
	 * Address of this location.
	 */
	var address: String = ""

	constructor() {
		this.latLng = LatLng(0.0, 0.0)
	}

	constructor(latLng: LatLng) {
		this.latLng = LatLng(latLng.latitude, latLng.longitude)
		this.hasSetLatLng = true
	}

	constructor(lat: Double, lng: Double) {
		this.latLng = LatLng(lat, lng)
		this.hasSetLatLng = true
	}

	fun copyFromLocation(loc: Location) {
		this.setLatLng(loc.latitude, loc.longitude)
		this.alt = loc.altitude
		this.bearing = loc.bearing
		this.speed = loc.speed
		this.accuracy = loc.accuracy
	}

	fun copyFromCameraPosition(position: CameraPosition) {
		this.setLatLng(position.target.latitude, position.target.longitude)
		this.bearing = position.bearing
		this.tilt = position.tilt
		this.zoom = position.zoom
	}

	fun hasSetLatLng(): Boolean {
		return this.hasSetLatLng
	}

	fun setLatLng(lat: Double, lng: Double) {
		this.latLng = LatLng(lat, lng)
		this.hasSetLatLng = true
	}

	fun unsetLatLng() {
		this.latLng = LatLng(0.0, 0.0)
		this.hasSetLatLng = false
	}

	override fun equals(other: Any?): Boolean {
		if (this === other) {
			return true
		}
		if (other == null || other.javaClass != javaClass) {
			return false
		}
		val that = other as DkGmapLocation

		// Check equality, not reference
		return this.latLng == that.latLng
	}

	override fun hashCode(): Int {
		var result = latLng.hashCode()
		result = 31 * result + alt.hashCode()
		result = 31 * result + bearing.hashCode()
		result = 31 * result + speed.hashCode()
		result = 31 * result + accuracy.hashCode()
		result = 31 * result + tilt.hashCode()
		result = 31 * result + zoom.hashCode()
		result = 31 * result + resolution.hashCode()
		result = 31 * result + (address.hashCode())
		return result
	}
}